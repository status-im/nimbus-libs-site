(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{368:function(t,e,s){"use strict";s.r(e);var a=s(44),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"eth"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eth"}},[t._v("#")]),t._v(" Eth")]),t._v(" "),s("p",[t._v("Ethereum-related utilities written in Nim. Includes things like Bloom filters, private/public key utilities, RLP, devp2p, and more.")]),t._v(" "),s("h2",{attrs:{id:"rlp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rlp"}},[t._v("#")]),t._v(" rlp")]),t._v(" "),s("h3",{attrs:{id:"introduction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),s("p",[t._v("A Nim implementation of the Recursive Length Prefix encoding (RLP) as specified\nin the Ethereum's "),s("a",{attrs:{href:"https://ethereum.github.io/yellowpaper/paper.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Yellow Paper"),s("OutboundLink")],1),t._v("\nand "),s("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/RLP",target:"_blank",rel:"noopener noreferrer"}},[t._v("Wiki"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"reading-rlp-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reading-rlp-data"}},[t._v("#")]),t._v(" Reading RLP data")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("Rlp")]),t._v(" type provided by this library represents a cursor over an RLP-encoded\nbyte stream.")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rlpFromBytes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" openArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("byte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Rlp\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"streaming-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#streaming-api"}},[t._v("#")]),t._v(" Streaming API")]),t._v(" "),s("p",[t._v("Once created, the "),s("code",[t._v("Rlp")]),t._v(" object will offer procs such as "),s("code",[t._v("isList")]),t._v(", "),s("code",[t._v("isBlob")]),t._v(",\n"),s("code",[t._v("getType")]),t._v(", "),s("code",[t._v("listLen")]),t._v(", "),s("code",[t._v("blobLen")]),t._v(" to determine the type of the value under\nthe cursor. The contents of blobs can be extracted with procs such as\n"),s("code",[t._v("toString")]),t._v(", "),s("code",[t._v("toBytes")]),t._v(" and "),s("code",[t._v("toInt")]),t._v(" without advancing the cursor.")]),t._v(" "),s("p",[t._v("Lists can be traversed with the standard "),s("code",[t._v("items")]),t._v(" iterator, which will advance\nthe cursor to each sub-item position and yield the "),s("code",[t._v("Rlp")]),t._v(" object at that point.\nAs an alternative, "),s("code",[t._v("listElem")]),t._v(" can return a new "),s("code",[t._v("Rlp")]),t._v(" object adjusted to a\nparticular sub-item position without advancing the original cursor.\nKeep in mind that copying "),s("code",[t._v("Rlp")]),t._v(" objects is cheap and you can create as many\ncursors pointing to different positions in the RLP stream as necessary.")]),t._v(" "),s("p",[s("code",[t._v("skipElem")]),t._v(" will advance the cursor to the next position in the current list.\n"),s("code",[t._v("hasData")]),t._v(" will indicate that there are no more bytes in the stream that can\nbe consumed.")]),t._v(" "),s("p",[t._v("Another way to extract data from the stream is through the universal "),s("code",[t._v("read")]),t._v("\nproc that accepts a type as a parameter. You can pass any supported type\nsuch as "),s("code",[t._v("string")]),t._v(", "),s("code",[t._v("int")]),t._v(", "),s("code",[t._v("seq[T]")]),t._v(", etc, including composite user-defined\ntypes (see "),s("a",{attrs:{href:"#object-serialization"}},[t._v("Object Serialization")]),t._v("). The cursor\nwill be advanced just past the end of the consumed object.")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("toXX")]),t._v(" and "),s("code",[t._v("read")]),t._v(" family of procs may raise a "),s("code",[t._v("RlpTypeMismatch")]),t._v(" in case\nof type mismatch with the stream contents under the cursor. A corrupted\nRLP stream or an attemp to read past the stream end will be signaled\nwith the "),s("code",[t._v("MalformedRlpError")]),t._v(" exception. If the RLP stream includes data\nthat cannot be processed on the current platform (e.g. an integer value\nthat is too large), the library will raise an "),s("code",[t._v("UnsupportedRlpError")]),t._v(" exception.")]),t._v(" "),s("h3",{attrs:{id:"dom-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dom-api"}},[t._v("#")]),t._v(" DOM API")]),t._v(" "),s("p",[t._v("Calling "),s("code",[t._v("Rlp.toNodes")]),t._v(" at any position within the stream will return a tree\nof "),s("code",[t._v("RlpNode")]),t._v(" objects representing the collection of values starting at that\nposition:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v("\n  RlpNodeType"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v("\n    rlpBlob\n    rlpList\n\n  RlpNode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" kind"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*:")]),t._v(" RlpNodeType\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("of")]),t._v(" rlpBlob"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n      bytes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*:")]),t._v(" seq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("byte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("of")]),t._v(" rlpList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n      elems"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*:")]),t._v(" seq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("RlpNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("As a short-cut, you can also call "),s("code",[t._v("decode")]),t._v(" directly on a byte sequence to\navoid creating a "),s("code",[t._v("Rlp")]),t._v(" object when obtaining the nodes.\nFor debugging purposes, you can also create a human readable representation\nof the Rlp nodes by calling the "),s("code",[t._v("inspect")]),t._v(" proc:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("inspect"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Rlp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" indent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"creating-rlp-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#creating-rlp-data"}},[t._v("#")]),t._v(" Creating RLP data")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("RlpWriter")]),t._v(" type can be used to encode RLP data. Instances are created\nwith the "),s("code",[t._v("initRlpWriter")]),t._v(" proc. This should be followed by one or more calls\nto "),s("code",[t._v("append")]),t._v(" which is overloaded to accept arbitrary values. Finally, you can\ncall "),s("code",[t._v("finish")]),t._v(" to obtain the final "),s("code",[t._v("seq[byte]")]),t._v(".")]),t._v(" "),s("p",[t._v("If the end result should be a RLP list of particular length, you can replace\nthe initial call to "),s("code",[t._v("initRlpWriter")]),t._v(" with "),s("code",[t._v("initRlpList(n)")]),t._v(". Calling "),s("code",[t._v("finish")]),t._v("\nbefore writing the sufficient number of elements will then result in an assertion failure.")]),t._v(" "),s("p",[t._v("As an alternative short-cut, you can also call "),s("code",[t._v("encode")]),t._v(" on an arbitrary value\n(including sequences and user-defined types) to execute all of the steps at\nonce and directly obtain the final RLP bytes. "),s("code",[t._v("encodeList(varargs)")]),t._v(" is another\nshort-cut for creating RLP lists.")]),t._v(" "),s("h3",{attrs:{id:"object-serialization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-serialization"}},[t._v("#")]),t._v(" Object serialization")]),t._v(" "),s("p",[t._v("As previously explained, generic procs such as "),s("code",[t._v("read")]),t._v(", "),s("code",[t._v("append")]),t._v(", "),s("code",[t._v("encode")]),t._v(" and\n"),s("code",[t._v("decode")]),t._v(" can be used with arbitrary used-defined object types. By default, the\nlibrary will serialize all of the fields of the object using the "),s("code",[t._v("fields")]),t._v("\niterator, but you can also include only a subset of the fields or modify the\norder of serialization or by employing the "),s("code",[t._v("rlpIgnore")]),t._v(" pragma or by using the\n"),s("code",[t._v("rlpFields")]),t._v(" macro:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("macro")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rlpFields"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" typedesc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fields"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" varargs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("untyped"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## example usage:")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v("\n  Transaction "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")]),t._v("\n    amount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" int\n    time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" DateTime\n    sender"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string\n    receiver"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string\n\nrlpFields Transaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  sender"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" receiver"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" amount\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rlp"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Transaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" bytes "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("encode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" t2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bytes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("decode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Transaction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br")])]),s("p",[t._v("By default, sub-fields within objects are wrapped in RLP lists. You can avoid this\nbehavior by adding the custom pragma "),s("code",[t._v("rlpInline")]),t._v(" on a particular field. In rare\ncircumstances, you may need to serialize the same field type differently depending\non the enclosing object type. You can use the "),s("code",[t._v("rlpCustomSerialization")]),t._v(" pragma to\nachieve this.")]),t._v(" "),s("h3",{attrs:{id:"contributing-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#contributing-testing"}},[t._v("#")]),t._v(" Contributing / Testing")]),t._v(" "),s("p",[t._v("To test the correctness of any modifications to the library, please execute\n"),s("code",[t._v("nimble test_rlp")]),t._v(" at the root of the repo.")]),t._v(" "),s("h2",{attrs:{id:"p2p"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#p2p"}},[t._v("#")]),t._v(" p2p")]),t._v(" "),s("h3",{attrs:{id:"introduction-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction-2"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),s("p",[t._v("This library implements the DevP2P family of networking protocols used\nin the Ethereum world.")]),t._v(" "),s("h3",{attrs:{id:"connecting-to-the-ethereum-network"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#connecting-to-the-ethereum-network"}},[t._v("#")]),t._v(" Connecting to the Ethereum network")]),t._v(" "),s("p",[t._v("A connection to the Ethereum network can be created by instantiating\nthe "),s("code",[t._v("EthereumNode")]),t._v(" type:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newEthereumNode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("keys"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" KeyPair"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                      listeningAddress"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                      networkId"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" uint"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                      chain"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" AbstractChainDB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                      clientId "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nim-eth-p2p"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                      addAllCapabilities "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" true"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" EthereumNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h4",{attrs:{id:"parameters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters:")]),t._v(" "),s("p",[s("code",[t._v("keys")]),t._v(":\nA pair of public and private keys used to authenticate the node\non the network and to determine its node ID.\nSee the "),s("RouterLink",{attrs:{to:"/lib/nim-eth/keys.html"}},[t._v("keys")]),t._v("\nlibrary for utilities that will help you generate and manage\nsuch keys.")],1),t._v(" "),s("p",[s("code",[t._v("listeningAddress")]),t._v(":\nThe network interface and port where your client will be\naccepting incoming connections.")]),t._v(" "),s("p",[s("code",[t._v("networkId")]),t._v(":\nThe Ethereum network ID. The client will disconnect immediately\nfrom any peers who don't use the same network.")]),t._v(" "),s("p",[s("code",[t._v("chain")]),t._v(":\nAn abstract instance of the Ethereum blockchain associated\nwith the node. This library allows you to plug any instance\nconforming to the abstract interface defined in the\n"),s("a",{attrs:{href:"https://github.com/status-im/nim-eth-common",target:"_blank",rel:"noopener noreferrer"}},[t._v("eth_common"),s("OutboundLink")],1),t._v("\npackage.")]),t._v(" "),s("p",[s("code",[t._v("clientId")]),t._v(":\nA name used to identify the software package connecting\nto the network (i.e. similar to the "),s("code",[t._v("User-Agent")]),t._v(" string\nin a browser).")]),t._v(" "),s("p",[s("code",[t._v("addAllCapabilities")]),t._v(":\nBy default, the node will support all RPLx protocols imported in\nyour project. You can specify "),s("code",[t._v("false")]),t._v(" if you prefer to create a\nnode with a more limited set of protocols. Use one or more calls\nto "),s("code",[t._v("node.addCapability")]),t._v(" to specify the desired set:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("node"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addCapability")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("eth"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nnode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addCapability")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("shh"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("Each supplied protocol identifier is a name of a protocol introduced\nby the "),s("code",[t._v("p2pProtocol")]),t._v(" macro discussed later in this document.")]),t._v(" "),s("p",[t._v("Instantiating an "),s("code",[t._v("EthereumNode")]),t._v(" does not immediately connect you to\nthe network. To start the connection process, call "),s("code",[t._v("node.connectToNetwork")]),t._v(":")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("connectToNetwork"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" EthereumNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       bootstrapNodes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" openarray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ENode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       startListening "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" true"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                       enableDiscovery "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" true"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("The "),s("code",[t._v("EthereumNode")]),t._v(" will automatically find and maintain a pool of peers\nusing the Ethereum node discovery protocol. You can access the pool as\n"),s("code",[t._v("node.peers")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"communicating-with-peers-using-rlpx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#communicating-with-peers-using-rlpx"}},[t._v("#")]),t._v(" Communicating with Peers using RLPx")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("RLPx"),s("OutboundLink")],1),t._v(" is the\nhigh-level protocol for exchanging messages between peers in the Ethereum\nnetwork. Most of the client code of this library should not be concerned\nwith the implementation details of the underlying protocols and should use\nthe high-level APIs described in this section.")]),t._v(" "),s("p",[t._v("The RLPx protocols are defined as a collection of strongly-typed messages,\nwhich are grouped into sub-protocols multiplexed over the same TCP connection.")]),t._v(" "),s("p",[t._v("This library represents each such message as a regular Nim function call\nover the "),s("code",[t._v("Peer")]),t._v(" object. Certain messages act only as notifications, while\nothers fit the request/response pattern.")]),t._v(" "),s("p",[t._v("To understand more about how messages are defined and used, let's look at\nthe definition of a RLPx protocol:")]),t._v(" "),s("h4",{attrs:{id:"rlpx-sub-protocols"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rlpx-sub-protocols"}},[t._v("#")]),t._v(" RLPx sub-protocols")]),t._v(" "),s("p",[t._v("The sub-protocols are defined with the "),s("code",[t._v("p2pProtocol")]),t._v(" macro. It will accept\na short identifier for the protocol and the current protocol version:")]),t._v(" "),s("p",[t._v("Here is how the "),s("a",{attrs:{href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#p2p-capability",target:"_blank",rel:"noopener noreferrer"}},[t._v("DevP2P wire protocol"),s("OutboundLink")],1),t._v(" might look like:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("p2pProtocol "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("DevP2P")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rlpxName "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"p2p"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n             version"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" uint"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n             clientId"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n             capabilities"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" openarray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Capability"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n             listenPort"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" uint"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n             nodeId"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" P2PNodeId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeId\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("disconnect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reason"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" DisconnectionReason"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ping")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    await peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pong")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pong")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    echo "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"received pong from "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("id\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("p",[t._v("As seen in the example above, a protocol definition determines both the\navailable messages that can be sent to another peer (e.g. as in "),s("code",[t._v("peer.pong()")]),t._v(")\nand the asynchronous code responsible for handling the incoming messages.")]),t._v(" "),s("h4",{attrs:{id:"protocol-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#protocol-state"}},[t._v("#")]),t._v(" Protocol state")]),t._v(" "),s("p",[t._v("The protocol implementations are expected to maintain a state and to act\nlike a state machine handling the incoming messages. You are allowed to\ndefine an arbitrary state type that can be specified in the "),s("code",[t._v("peerState")]),t._v("\nprotocol option. Later, instances of the state object can be obtained\nthough the "),s("code",[t._v("state")]),t._v(" pseudo-field of the "),s("code",[t._v("Peer")]),t._v(" object:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" AbcPeerState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")]),t._v("\n  receivedMsgsCount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" int\n\np2pProtocol "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("abc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                peerState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" AbcPeerState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("incomingMessage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("receivedMsgsCount "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[t._v("Besides the per-peer state demonstrated above, there is also support\nfor maintaining a network-wide state. It's enabled by specifying the\n"),s("code",[t._v("networkState")]),t._v(" option of the protocol and the state object can be obtained\nthrough accessor of the same name.")]),t._v(" "),s("p",[t._v("The state objects are initialized to zero by default, but you can modify\nthis behaviour by overriding the following procs for your state types:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initProtocolState"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" MyPeerState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initProtocolState"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" MyNetworkState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" EthereumNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("Sometimes, you'll need to access the state of another protocol.\nTo do this, specify the protocol identifier to the "),s("code",[t._v("state")]),t._v(" accessors:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("  echo "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ABC protocol messages: "')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("abc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("receivedMsgCount\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("While the state machine approach may be a particularly robust way of\nimplementing sub-protocols (it is more amenable to proving the correctness\nof the implementation through formal verification methods), sometimes it may\nbe more convenient to use more imperative style of communication where the\ncode is able to wait for a particular response after sending a particular\nrequest. The library provides two mechanisms for achieving this:")]),t._v(" "),s("h4",{attrs:{id:"waiting-particular-messages-with-nextmsg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#waiting-particular-messages-with-nextmsg"}},[t._v("#")]),t._v(" Waiting particular messages with "),s("code",[t._v("nextMsg")])]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("nextMsg")]),t._v(" helper proc can be used to pause the execution of an async\nproc until a particular incoming message from a peer arrives:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("helloExample")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# send a hello message")]),t._v("\n  await peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".)")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# wait for a matching hello response, might want to add a timeout here")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" response "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" await peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextMsg")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p2p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("hello"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  echo response"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("clientId "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# print the name of the Ethereum client")]),t._v("\n                         "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# used by the other peer (Geth, Parity, Nimbus, etc)")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[t._v("There are few things to note in the above example:")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("The "),s("code",[t._v("p2pProtocol")]),t._v(" definition created a pseudo-variable named after the\nprotocol holding various properties of the protocol.")])]),t._v(" "),s("li",[s("p",[t._v("Each message defined in the protocol received a corresponding type name,\nmatching the message name (e.g. "),s("code",[t._v("p2p.hello")]),t._v("). This type will have fields\nmatching the parameter names of the message. If the messages has "),s("code",[t._v("openarray")]),t._v("\nparams, these will be remapped to "),s("code",[t._v("seq")]),t._v(" types.")])])]),t._v(" "),s("p",[t._v("If the designated messages also has an attached handler, the future returned\nby "),s("code",[t._v("nextMsg")]),t._v(" will be resolved only after the handler has been fully executed\n(so you can count on any side effects produced by the handler to have taken\nplace). If there are multiple outstanding calls to "),s("code",[t._v("nextMsg")]),t._v(", they will\ncomplete together. Any other messages received in the meantime will still\nbe dispatched to their respective handlers.")]),t._v(" "),s("p",[t._v("Please also note that the "),s("code",[t._v("p2pProtocol")]),t._v(" macro will make this "),s("code",[t._v("helloExample")]),t._v(" proc\n"),s("code",[t._v("async")]),t._v(". Practically see it as "),s("code",[t._v("proc helloExample(peer: Peer) {.async.}")]),t._v(", and\nthus never use "),s("code",[t._v("waitFor")]),t._v(", but rather "),s("code",[t._v("await")]),t._v(" inside this proc.")]),t._v(" "),s("p",[t._v("For implementing protocol handshakes with "),s("code",[t._v("nextMsg")]),t._v(" there are specific helpers\nwhich are explained "),s("a",{attrs:{href:"https://github.com/status-im/nim-eth/blob/master/doc/p2p.md#implementing-handshakes-and-reacting-to-other-events",target:"_blank",rel:"noopener noreferrer"}},[t._v("below"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"requestresponse-pairs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#requestresponse-pairs"}},[t._v("#")]),t._v(" "),s("code",[t._v("requestResponse")]),t._v(" pairs")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("p2pProtocol "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("les")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n\n  requestResponse"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getProofs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" proofs"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" openarray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ProofRequest"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("proofs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" BV"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" uint"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" proofs"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" openarray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Blob"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("p",[t._v("Two or more messages within the protocol may be grouped into a\n"),s("code",[t._v("requestResponse")]),t._v(" block. The last message in the group is assumed\nto be the response while all other messages are considered requests.")]),t._v(" "),s("p",[t._v("When a request message is sent, the return type will be a "),s("code",[t._v("Future")]),t._v("\nthat will be completed once the response is received. Please note\nthat there is a mandatory timeout parameter, so the actual return\ntype is "),s("code",[t._v("Future[Option[MessageType]]")]),t._v(". The "),s("code",[t._v("timeout")]),t._v(" parameter can\nbe specified for each individual call and the default value can be\noverridden on the level of individual message, or the entire protocol:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("p2pProtocol "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("abc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                useRequestIds "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" false"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                timeout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# value in milliseconds")]),t._v("\n  requestResponse"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myReq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dataId"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" int"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" timeout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myRes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("By default, the library will take care of inserting a hidden "),s("code",[t._v("reqId")]),t._v("\nparameter as used in the "),s("a",{attrs:{href:"https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29",target:"_blank",rel:"noopener noreferrer"}},[t._v("LES protocol"),s("OutboundLink")],1),t._v(",\nbut you can disable this behavior by overriding the protocol setting\n"),s("code",[t._v("useRequestIds")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"implementing-handshakes-and-reacting-to-other-events"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#implementing-handshakes-and-reacting-to-other-events"}},[t._v("#")]),t._v(" Implementing handshakes and reacting to other events")]),t._v(" "),s("p",[t._v("Besides message definitions and implementations, a protocol specification may\nalso include handlers for certain important events such as newly connected\npeers or misbehaving or disconnecting peers:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("p2pProtocol "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fooVersion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  onPeerConnected "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" m "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" await peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("status")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fooVersion"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                              timeout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" chronos"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("milliseconds")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("protocolVersion "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" fooVersion"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n      debug "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Foo peer"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fooVersion\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("raise")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UselessPeerError"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Incompatible Foo version"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  onPeerDisconnected "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reason"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" DisconnectionReason"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    debug "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"peer disconnected"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" peer\n\n  handshake"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("proc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("status")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Peer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                protocolVersion"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" uint"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("p",[t._v("For handshake messages, where the same type of message needs to be send to and\nreceived from the peer, a "),s("code",[t._v("handshake")]),t._v(" helper is introduced, as you can see in\nthe code example above.")]),t._v(" "),s("p",[t._v("Thanks to the "),s("code",[t._v("handshake")]),t._v(" helper the "),s("code",[t._v("status")]),t._v(" message will both be send, and be\nawaited for receival from the peer, with the defined timeout. In case no "),s("code",[t._v("status")]),t._v("\nmessage is received within the defined timeout, an error will be raised which\nwill result in a disconnect from the peer.")]),t._v(" "),s("p",[s("strong",[t._v("Note:")]),t._v(" Be aware that if currently one of the subprotocol "),s("code",[t._v("onPeerConnected")]),t._v("\ncalls fails, the client will be disconnected as "),s("code",[t._v("UselessPeer")]),t._v(" but no\n"),s("code",[t._v("onPeerDisconnect")]),t._v(" calls are run.")]),t._v(" "),s("h4",{attrs:{id:"checking-the-other-peer-s-supported-sub-protocols"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#checking-the-other-peer-s-supported-sub-protocols"}},[t._v("#")]),t._v(" Checking the other peer's supported sub-protocols")]),t._v(" "),s("p",[t._v("Upon establishing a connection, RLPx will automatically negotiate the list of\nmutually supported protocols by the peers. To check whether a particular peer\nsupports a particular sub-protocol, use the following code:")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("supports")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("les"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# `les` is the identifier of the light clients sub-protocol")]),t._v("\n  peer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getReceipts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextReqId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("neededReceipts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h2",{attrs:{id:"keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keys"}},[t._v("#")]),t._v(" keys")]),t._v(" "),s("p",[t._v("This library is a Nim re-implementation of "),s("a",{attrs:{href:"https://github.com/ethereum/eth-keys",target:"_blank",rel:"noopener noreferrer"}},[t._v("eth-keys"),s("OutboundLink")],1),t._v(": the common API for working with Ethereum's public and private keys, signatures, and addresses.")]),t._v(" "),s("p",[t._v("By default, Nim eth-keys uses Bitcoin's "),s("a",{attrs:{href:"https://github.com/bitcoin-core/secp256k1",target:"_blank",rel:"noopener noreferrer"}},[t._v("libsecp256k1"),s("OutboundLink")],1),t._v(" as a backend. Make sure libsecp256k1 is available on your system.")]),t._v(" "),s("p",[t._v("An experimental pure Nim backend (Warning : do not use in production) is available with the compilation switch "),s("code",[t._v("-d:backend_native")])]),t._v(" "),s("h2",{attrs:{id:"keyfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keyfile"}},[t._v("#")]),t._v(" keyfile")]),t._v(" "),s("h3",{attrs:{id:"introduction-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction-3"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),s("p",[t._v("This library is a Nim reimplementation of "),s("a",{attrs:{href:"https://github.com/ethereum/eth-keyfile",target:"_blank",rel:"noopener noreferrer"}},[t._v("ethereum/eth-keyfile"),s("OutboundLink")],1),t._v(", which is used to create and load Ethereum "),s("code",[t._v("keyfile")]),t._v(" format and the tools for handling the format and for storing private keys. Currently, the library supports only the PBKDF2 method and does not support the Scrypt method.")]),t._v(" "),s("h2",{attrs:{id:"trie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#trie"}},[t._v("#")]),t._v(" trie")]),t._v(" "),s("h2",{attrs:{id:"nim-implementation-of-the-ethereum-trie-structure"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nim-implementation-of-the-ethereum-trie-structure"}},[t._v("#")]),t._v(" Nim Implementation of the Ethereum Trie structure")]),t._v(" "),s("h3",{attrs:{id:"hexary-trie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hexary-trie"}},[t._v("#")]),t._v(" Hexary Trie")]),t._v(" "),s("h3",{attrs:{id:"binary-trie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#binary-trie"}},[t._v("#")]),t._v(" Binary Trie")]),t._v(" "),s("p",[t._v("Binary-trie is a dictionary-like data structure to store key-value pair.\nMuch like it's sibling Hexary-trie, the key-value pair will be stored into key-value flat-db.\nThe primary difference with Hexary-trie is, each node of Binary-trie only consist of one or two child,\nwhile Hexary-trie node can contains up to 16 or 17 child-nodes.")]),t._v(" "),s("p",[t._v("Unlike Hexary-trie, Binary-trie store it's data into flat-db without using rlp encoding.\nBinary-trie store its value using simple "),s("strong",[t._v("Node-Types")]),t._v(" encoding.\nThe encoded-node will be hashed by keccak_256 and the hash value will be the key to flat-db.\nEach entry in the flat-db will looks like:")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("key")]),t._v(" "),s("th",[t._v("value")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("32-bytes-keccak-hash")]),t._v(" "),s("td",[t._v("encoded-node(KV or BRANCH or LEAF encoded)")])])])]),t._v(" "),s("h4",{attrs:{id:"node-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-types"}},[t._v("#")]),t._v(" Node-Types")]),t._v(" "),s("ul",[s("li",[t._v("KV = [0, encoded-key-path, 32 bytes hash of child]")]),t._v(" "),s("li",[t._v("BRANCH = [1, 32 bytes hash of left child, 32 bytes hash of right child]")]),t._v(" "),s("li",[t._v("LEAF = [2, value]")])]),t._v(" "),s("p",[t._v("The KV node can have BRANCH node or LEAF node as it's child, but cannot a KV node.\nThe internal algorithm will merge a KV(parent)->KV(child) into one KV node.\nEvery KV node contains encoded keypath to reduce the number of blank nodes.")]),t._v(" "),s("p",[t._v("The BRANCH node can have KV, BRANCH, or LEAF node as it's children.")]),t._v(" "),s("p",[t._v("The LEAF node is the terminal node, it contains the value of a key.")]),t._v(" "),s("h4",{attrs:{id:"encoded-key-path"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#encoded-key-path"}},[t._v("#")]),t._v(" encoded-key-path")]),t._v(" "),s("p",[t._v("While Hexary-trie encode the path using Hex-Prefix encoding, Binary-trie\nencode the path using binary encoding, the scheme looks like this table below.")]),t._v(" "),s("div",{staticClass:"language-text line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("            |--------- odd --------|\n       00mm yyyy xxxx xxxx xxxx xxxx\n            |------ even -----|\n  1000 00mm yyyy xxxx xxxx xxxx\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("table",[s("thead",[s("tr",[s("th",[t._v("symbol")]),t._v(" "),s("th",[t._v("explanation")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("xxxx")]),t._v(" "),s("td",[t._v("nibble of binary keypath in bits, 0 = left, 1 = right")])]),t._v(" "),s("tr",[s("td",[t._v("yyyy")]),t._v(" "),s("td",[t._v("nibble contains 0-3 bits padding + binary keypath")])]),t._v(" "),s("tr",[s("td",[t._v("mm")]),t._v(" "),s("td",[t._v("number of binary keypath bits modulo 4 (0-3)")])]),t._v(" "),s("tr",[s("td",[t._v("00")]),t._v(" "),s("td",[t._v("zero zero prefix")])]),t._v(" "),s("tr",[s("td",[t._v("1000")]),t._v(" "),s("td",[t._v("even numbered nibbles prefix")])])])]),t._v(" "),s("p",[t._v("if there is no padding, then yyyy bit sequence is absent, mm also zero.\nyyyy = mm bits + padding bits must be 4 bits length.")]),t._v(" "),s("h4",{attrs:{id:"the-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-api"}},[t._v("#")]),t._v(" The API")]),t._v(" "),s("p",[t._v("The primary API for Binary-trie is "),s("code",[t._v("set")]),t._v(" and "),s("code",[t._v("get")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("set(key, value)  ---  "),s("em",[t._v("store a value associated with a key")])]),t._v(" "),s("li",[t._v("get(key): value  --- "),s("em",[t._v("get a value using a key")])])]),t._v(" "),s("p",[t._v("Both "),s("code",[t._v("key")]),t._v(" and "),s("code",[t._v("value")]),t._v(" are of "),s("code",[t._v("seq[byte]")]),t._v(" type. And they cannot have zero length.")]),t._v(" "),s("p",[t._v("Getting a non-existent key will return zero length seq[byte].")]),t._v(" "),s("p",[t._v("Binary-trie also provide dictionary syntax API for "),s("code",[t._v("set")]),t._v(" and "),s("code",[t._v("get")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("trie[key] = value -- same as "),s("code",[t._v("set")])]),t._v(" "),s("li",[t._v("value = trie[key] -- same as "),s("code",[t._v("get")])]),t._v(" "),s("li",[t._v("contains(key) a.k.a. "),s("code",[t._v("in")]),t._v(" operator")])]),t._v(" "),s("p",[t._v("Additional APIs are:")]),t._v(" "),s("ul",[s("li",[t._v("exists(key) -- returns "),s("code",[t._v("bool")]),t._v(", to check key-value existence -- same as contains")]),t._v(" "),s("li",[t._v("delete(key) -- remove a key-value from the trie")]),t._v(" "),s("li",[t._v("deleteSubtrie(key) -- remove a key-value from the trie plus all of it's subtrie\nthat starts with the same key prefix")]),t._v(" "),s("li",[t._v("rootNode() -- get root node")]),t._v(" "),s("li",[t._v("rootNode(node) -- replace the root node")]),t._v(" "),s("li",[t._v("getRootHash(): "),s("code",[t._v("KeccakHash")]),t._v(" with "),s("code",[t._v("seq[byte]")]),t._v(" type")]),t._v(" "),s("li",[t._v("getDB(): "),s("code",[t._v("DB")]),t._v(" -- get flat-db pointer")])]),t._v(" "),s("p",[t._v("Constructor API:")]),t._v(" "),s("ul",[s("li",[t._v("initBinaryTrie(DB, rootHash[optional]) -- rootHash has "),s("code",[t._v("seq[byte]")]),t._v(" or KeccakHash type")]),t._v(" "),s("li",[t._v("init(BinaryTrie, DB, rootHash[optional])")])]),t._v(" "),s("p",[t._v("Normally you would not set the rootHash when constructing an empty Binary-trie.\nSetting the rootHash occured in a scenario where you have a populated DB\nwith existing trie structure and you know the rootHash,\nand then you want to continue/resume the trie operations.")]),t._v(" "),s("h3",{attrs:{id:"examples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v("\n  eth"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" binary"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" utils"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" db "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newMemoryDB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" trie "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initBinaryTrie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("toBytes\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value2"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("toBytes\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## delete all subtrie with key prefixes "key"')]),t._v("\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteSubtrie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\ntrie"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"moon"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sun"')]),t._v("\ndoAssert "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"moon"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" trie\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"moon"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sun"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("toBytes\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br")])]),s("p",[t._v("Remember, "),s("code",[t._v("set")]),t._v(" and "),s("code",[t._v("get")]),t._v(" are trie operations. A single "),s("code",[t._v("set")]),t._v(" operation may invoke\nmore than one store/lookup operation into the underlying DB. The same is also happened to "),s("code",[t._v("get")]),t._v(" operation,\nit could do more than one flat-db lookup before it return the requested value.")]),t._v(" "),s("h3",{attrs:{id:"the-truth-behind-a-lie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-truth-behind-a-lie"}},[t._v("#")]),t._v(" The truth behind a lie")]),t._v(" "),s("p",[t._v("What kind of lie? actually, "),s("code",[t._v("delete")]),t._v(" and "),s("code",[t._v("deleteSubtrie")]),t._v(" doesn't remove the\n'deleted' node from the underlying DB. It only make the node inaccessible\nfrom the user of the trie. The same also happened if you update the value of a key,\nthe old value node is not removed from the underlying DB.\nA more subtle lie also happened when you add new entrie into the trie using "),s("code",[t._v("set")]),t._v(" operation.\nThe previous hash of affected branch become obsolete and replaced by new hash,\nthe old hash become inaccessible to the user.\nYou may think that is a waste of storage space.\nLuckily, we also provide some utilities to deal with this situation, the branch utils.")]),t._v(" "),s("h3",{attrs:{id:"the-branch-utils"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-branch-utils"}},[t._v("#")]),t._v(" The branch utils")]),t._v(" "),s("p",[t._v("The branch utils consist of these API:")]),t._v(" "),s("ul",[s("li",[t._v("checkIfBranchExist(DB; rootHash; keyPrefix): bool")]),t._v(" "),s("li",[t._v("getBranch(DB; rootHash; key): branch")]),t._v(" "),s("li",[t._v("isValidBranch(branch, rootHash, key, value): bool")]),t._v(" "),s("li",[t._v("getWitness(DB; nodeHash; key): branch")]),t._v(" "),s("li",[t._v("getTrieNodes(DB; nodeHash): branch")])]),t._v(" "),s("p",[s("code",[t._v("keyPrefix")]),t._v(", "),s("code",[t._v("key")]),t._v(", and "),s("code",[t._v("value")]),t._v(" are bytes container with length greater than zero.\nThey can be openArray[byte].")]),t._v(" "),s("p",[s("code",[t._v("rootHash")]),t._v(" and "),s("code",[t._v("nodeHash")]),t._v(" also bytes container,\nbut they have constraint: must be 32 bytes in length, and it must be a keccak_256 hash value.")]),t._v(" "),s("p",[s("code",[t._v("branch")]),t._v(" is a list of nodes, or in this case a "),s("code",[t._v("seq[seq[byte]]")]),t._v(".\nA list? yes, the structure is stored along with the encoded node.\nTherefore a list is enough to reconstruct the entire trie/branch.")]),t._v(" "),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v("\n  eth"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" binary"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" utils"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" db "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newMemoryDB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" trie "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initBinaryTrie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkIfBranchExist")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" true\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkIfBranchExist")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" true\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkIfBranchExist")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ken"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" false\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkIfBranchExist")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key123"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" false\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[t._v("The tree will looks like:")]),t._v(" "),s("div",{staticClass:"language-text line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("    root ---\x3e  A(kvnode, *common key prefix*)\n                         |\n                         |\n                         |\n                    B(branchnode)\n                     /         \\\n                    /           \\\n                   /             \\\nC1(kvnode, *remain kepath*) C2(kvnode, *remain kepath*)\n            |                           |\n            |                           |\n            |                           |\n  D1(leafnode, b'value1')       D2(leafnode, b'value2')\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" branchA "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A, B, C1, D1]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" branchB "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A, B, C2, D2]")]),t._v("\n\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValidBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("branchA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" true\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## wrong key, return zero bytes")]),t._v("\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValidBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("branchA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key5"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" true\n\ndoAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValidBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("branchB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# InvalidNode")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A]")]),t._v("\n\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key123"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# InvalidKeyError")]),t._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBranch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key5"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# there is still branch for non-exist key")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" branch "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getWitness")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## equivalent to `getBranch(db, trie.getRootHash(), "key1")`')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A, B, C1, D1]")]),t._v("\n\nbranch "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getWitness")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"key"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## this will include additional nodes of "key2"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A, B, C1, D1, C2, D2]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" wholeTrie "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getWitness")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## this will return the whole trie")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [A, B, C1, D1, C2, D2]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" branch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# B")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" nodeHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" keccak256"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("digest")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("baseAddr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("uint")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" nodes "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTrieNodes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nodeHash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndoAssert nodes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" wholeTrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ==> [B, C1, D1, C2, D2]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br")])]),s("h3",{attrs:{id:"remember-the-lie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remember-the-lie"}},[t._v("#")]),t._v(" Remember the lie?")]),t._v(" "),s("p",[t._v("Because trie "),s("code",[t._v("delete")]),t._v(", "),s("code",[t._v("deleteSubtrie")]),t._v(" and "),s("code",[t._v("set")]),t._v(" operation create inaccessible nodes in the underlying DB,\nwe need to remove them if necessary. We already see that "),s("code",[t._v('wholeTrie = getWitness(db, trie.getRootHash(), "")')]),t._v("\nwill return the whole trie, a list of accessible nodes.\nThen we can write the clean tree into a new DB instance to replace the old one.")]),t._v(" "),s("h3",{attrs:{id:"sparse-merkle-trie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sparse-merkle-trie"}},[t._v("#")]),t._v(" Sparse Merkle Trie")]),t._v(" "),s("p",[t._v("Sparse Merkle Trie(SMT) is a variant of Binary Trie which uses binary encoding to\nrepresent path during trie travelsal. When Binary Trie uses three types of node,\nSMT only use one type of node without any additional special encoding to store it's key-path.")]),t._v(" "),s("p",[t._v("Actually, it doesn't even store it's key-path anywhere like Binary Trie,\nthe key-path is stored implicitly in the trie structure during key-value insertion.")]),t._v(" "),s("p",[t._v("Because the key-path is not encoded in any special ways, the bits can be extracted directly from\nthe key without any conversion.")]),t._v(" "),s("p",[t._v("However, the key restricted to a fixed length because the algorithm demand a fixed height trie\nto works properly. In this case, the trie height is limited to 160 level,\nor the key is of fixed length 20 bytes (8 bits x 20 = 160).")]),t._v(" "),s("p",[t._v("To be able to use variable length key, the algorithm can be adapted slightly using hashed key before\nconstructing the binary key-path. For example, if using keccak256 as the hashing function,\nthen the height of the tree will be 256, but the key itself can be any length.")]),t._v(" "),s("h4",{attrs:{id:"the-api-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-api-2"}},[t._v("#")]),t._v(" The API")]),t._v(" "),s("p",[t._v("The primary API for Binary-trie is "),s("code",[t._v("set")]),t._v(" and "),s("code",[t._v("get")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("set(key, value, rootHash[optional])  ---  "),s("em",[t._v("store a value associated with a key")])]),t._v(" "),s("li",[t._v("get(key, rootHash[optional]): value  --- "),s("em",[t._v("get a value using a key")])])]),t._v(" "),s("p",[t._v("Both "),s("code",[t._v("key")]),t._v(" and "),s("code",[t._v("value")]),t._v(" are of "),s("code",[t._v("BytesRange")]),t._v(" type. And they cannot have zero length.\nYou can also use convenience API "),s("code",[t._v("get")]),t._v(" and "),s("code",[t._v("set")]),t._v(" which accepts\n"),s("code",[t._v("Bytes")]),t._v(" or "),s("code",[t._v("string")]),t._v(" (a "),s("code",[t._v("string")]),t._v(" is conceptually wrong in this context\nand may costlier than a "),s("code",[t._v("BytesRange")]),t._v(", but it is good for testing purpose).")]),t._v(" "),s("p",[t._v("rootHash is an optional parameter. When used, "),s("code",[t._v("get")]),t._v(" will get a key from specific root,\nand "),s("code",[t._v("set")]),t._v(" will also set a key at specific root.")]),t._v(" "),s("p",[t._v("Getting a non-existent key will return zero length BytesRange or a zeroBytesRange.")]),t._v(" "),s("p",[t._v("Sparse Merkle Trie also provide dictionary syntax API for "),s("code",[t._v("set")]),t._v(" and "),s("code",[t._v("get")]),t._v(".")]),t._v(" "),s("ul",[s("li",[t._v("trie[key] = value -- same as "),s("code",[t._v("set")])]),t._v(" "),s("li",[t._v("value = trie[key] -- same as "),s("code",[t._v("get")])]),t._v(" "),s("li",[t._v("contains(key) a.k.a. "),s("code",[t._v("in")]),t._v(" operator")])]),t._v(" "),s("p",[t._v("Additional APIs are:")]),t._v(" "),s("ul",[s("li",[t._v("exists(key) -- returns "),s("code",[t._v("bool")]),t._v(", to check key-value existence -- same as contains")]),t._v(" "),s("li",[t._v("delete(key) -- remove a key-value from the trie")]),t._v(" "),s("li",[t._v("getRootHash(): "),s("code",[t._v("KeccakHash")]),t._v(" with "),s("code",[t._v("BytesRange")]),t._v(" type")]),t._v(" "),s("li",[t._v("getDB(): "),s("code",[t._v("DB")]),t._v(" -- get flat-db pointer")]),t._v(" "),s("li",[t._v("prove(key, rootHash[optional]): proof -- useful for merkling")])]),t._v(" "),s("p",[t._v("Constructor API:")]),t._v(" "),s("ul",[s("li",[t._v("initSparseBinaryTrie(DB, rootHash[optional])")]),t._v(" "),s("li",[t._v("init(SparseBinaryTrie, DB, rootHash[optional])")])]),t._v(" "),s("p",[t._v("Normally you would not set the rootHash when constructing an empty Sparse Merkle Trie.\nSetting the rootHash occured in a scenario where you have a populated DB\nwith existing trie structure and you know the rootHash,\nand then you want to continue/resume the trie operations.")]),t._v(" "),s("h3",{attrs:{id:"examples-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples-2"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v("\n  eth"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sparse_binary"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" utils"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v("\n  db "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newMemoryDB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  trie "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initSparseMerkleTrie")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("\n  key1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"01234567890123456789"')]),t._v("\n  key2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"abcdefghijklmnopqrst"')]),t._v("\n\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value1"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("toBytes\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value2"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("toBytes\n\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\ntrie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndoAssert trie"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br")])]),s("p",[t._v("Remember, "),s("code",[t._v("set")]),t._v(" and "),s("code",[t._v("get")]),t._v(" are trie operations. A single "),s("code",[t._v("set")]),t._v(" operation may invoke\nmore than one store/lookup operation into the underlying DB. The same is also happened to "),s("code",[t._v("get")]),t._v(" operation,\nit could do more than one flat-db lookup before it return the requested value.\nWhile Binary Trie perform a variable numbers of lookup and store operations, Sparse Merkle Trie\nwill do constant numbers of lookup and store operations each "),s("code",[t._v("get")]),t._v(" and "),s("code",[t._v("set")]),t._v(" operation.")]),t._v(" "),s("h3",{attrs:{id:"merkle-proofing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#merkle-proofing"}},[t._v("#")]),t._v(" Merkle Proofing")]),t._v(" "),s("p",[t._v("Using "),s("code",[t._v("prove")]),t._v(" dan "),s("code",[t._v("verifyProof")]),t._v(" API, we can do some merkling with SMT.")]),t._v(" "),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("\n    value1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello world"')]),t._v("\n    badValue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bad value"')]),t._v("\n\n  trie"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" value1\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" proof "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("prove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  doAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("verifyProof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("proof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" true\n  doAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("verifyProof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("proof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" badValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" false\n  doAssert "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("verifyProof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("proof"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" trie"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRootHash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" false\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("h2",{attrs:{id:"bloom-an-ethereum-bloom-filter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bloom-an-ethereum-bloom-filter"}},[t._v("#")]),t._v(" bloom: an Ethereum Bloom Filter")]),t._v(" "),s("h2",{attrs:{id:"introduction-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction-4"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),s("p",[t._v("A Nim implementation of the bloom filter used by Ethereum.")]),t._v(" "),s("h2",{attrs:{id:"description"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Bloom_filter",target:"_blank",rel:"noopener noreferrer"}},[t._v("Bloom filters"),s("OutboundLink")],1),t._v(" are data structures that use hash functions to test whether an element is a member of a set. They work like other data structures but are probabilistic in nature: that is, they allow false positive matches but not false negative. Bloom filters use less storage space than other data structures.")]),t._v(" "),s("p",[t._v("Ethereum bloom filters are implemented with the Keccak-256 cryptographic hash function.")]),t._v(" "),s("p",[t._v("To see the bloom filter used in the context of Ethereum, please refer to the "),s("a",{attrs:{href:"https://ethereum.github.io/yellowpaper/paper.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Ethereum Yellow Paper"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"usage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[t._v("#")]),t._v(" Usage")]),t._v(" "),s("div",{staticClass:"language-nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" eth"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("bloom"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" stint\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" BloomFilter\nf"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("incl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doAssert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test1"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doAssert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test2"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("notin")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nf"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("incl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test2"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doAssert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test2"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doAssert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("toHex "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000200000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("h2",{attrs:{id:"node-discovery-protocol-v5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-discovery-protocol-v5"}},[t._v("#")]),t._v(" Node Discovery Protocol v5")]),t._v(" "),s("h3",{attrs:{id:"introduction-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction-5"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("eth/p2p/discoveryv5")]),t._v(" directory holds a Nim implementation of the\n"),s("a",{attrs:{href:"https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node Discovery Protocol v5.1"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("p",[t._v("The implemented specification is Protocol version v5.1.")]),t._v(" "),s("p",[t._v('This implementation does not support "Topic Advertisement" yet as this part of\nthe specification is not complete.')]),t._v(" "),s("p",[t._v("The implementation relies on other modules in the "),s("code",[t._v("eth")]),t._v(" package, namely: "),s("code",[t._v("keys")]),t._v(",\n"),s("code",[t._v("rlp")]),t._v(" and "),s("code",[t._v("async_utils")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"how-to-use"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-to-use"}},[t._v("#")]),t._v(" How to use")]),t._v(" "),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("\n  rng "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" keys"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("newRng\n  privKey "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" PrivateKey"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("random")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rng"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tcpPort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" udpPort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setupNat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Or fill in external IP/ports manually")]),t._v("\n  d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newProtocol")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("privKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tcpPort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" udpPort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rng "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rng"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nd"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("open")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Start listening")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("This will initialize the "),s("code",[t._v("Protocol")]),t._v(" and start listening. However, as no\nbootstrap nodes were passed in the "),s("code",[t._v("newProtocol")]),t._v(' call, the created ENR will need\nto be advertised somehow ("out of band"), so that the node can become known to\nother nodes in the network.')]),t._v(" "),s("p",[t._v("To initialize with a bootnode or a set of bootnodes, the ENRs need to be passed\nas parameter in "),s("code",[t._v("newProtocol")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-Nim line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-nim"}},[s("code",[t._v("d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("newProtocol")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("privKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ip"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tcpPort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" udpPort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      bootstrapRecords "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bootnodes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nd"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("open")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Start listening and add bootstrap nodes to the routing table.")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("Next there are two ways to run the protocol.")]),t._v(" "),s("p",[t._v("One can call "),s("code",[t._v("d.start()")]),t._v(" and two loops will be started:")]),t._v(" "),s("ol",[s("li",[t._v("Refresh loop")]),t._v(" "),s("li",[t._v("Revalidation loop")])]),t._v(" "),s("p",[t._v("The first loop will at specific interval do a query with a random "),s("code",[t._v("NodeId")]),t._v(" if no\nmanual queries were done for more than that interval period.\nThis query will add discovered nodes to the routing table.\nThe second loop will at random ranged interval send a ping to the least recently\nseen node in a random bucket. This is to keep the routing table cleared of\nunreachable/dead nodes.")]),t._v(" "),s("p",[t._v("Now within the application, manual queries or lookups can be done, for which\nthe discovered nodes can be used. Nodes discovered during this process will be\nattempted to be added to the routing table. One can use the "),s("code",[t._v("query")]),t._v(", "),s("code",[t._v("queryRandom")]),t._v("\nor "),s("code",[t._v("lookup")]),t._v(" calls for this. "),s("code",[t._v("randomNodes")]),t._v(" can also be used to find nodes,\nbut this will only look into the current routing table and not actively\nsearch for nodes on the network.")]),t._v(" "),s("p",[t._v("Or, one can decide not to run "),s("code",[t._v("d.start()")]),t._v(" and do this manually within its\napplication by using the available calls:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("query")]),t._v(", "),s("code",[t._v("queryRandom")]),t._v(" or "),s("code",[t._v("lookup")]),t._v(" for discovering more peers.")]),t._v(" "),s("li",[s("code",[t._v("revalidateNode")]),t._v(" or directly "),s("code",[t._v("ping")]),t._v(" for revalidating nodes.")])]),t._v(" "),s("p",[t._v("Of course, in either scenario, lookups can still be done for actually finding a\nspecific node. There is a "),s("code",[t._v("resolve")]),t._v(" call that can help with this, it will first\nlook in the local routing table and if it finds the node it will try to contact\nthe node directly to check if the ENR is up to date. If any of this fail a\n"),s("code",[t._v("lookup")]),t._v(" will be done.")]),t._v(" "),s("h3",{attrs:{id:"test-suite"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-suite"}},[t._v("#")]),t._v(" Test suite")]),t._v(" "),s("p",[t._v("To run the test suite specifically for discovery v5 related (discovery v5 + its\nnim-eth dependencies) tests, one can run following command:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Install required modules")]),t._v("\nnimble "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Run only discovery v5 related test suite")]),t._v("\nnimble tests_discv5_full\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h3",{attrs:{id:"dcli"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dcli"}},[t._v("#")]),t._v(" dcli")]),t._v(" "),s("p",[t._v("This is a small command line application that allows you to run a discovery\nnode. It also has the options to do a "),s("code",[t._v("ping")]),t._v(" or "),s("code",[t._v("findNode")]),t._v(" request to a specific\nnode, by providing its ENR.")]),t._v(" "),s("h4",{attrs:{id:"example-usage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#example-usage"}},[t._v("#")]),t._v(" Example usage")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Install required modules")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Make sure you have the latest modules, do NOT trust nimble on this.")]),t._v("\nnimble "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Build dcli")]),t._v("\nnim c -d:chronicles_log_level:trace -d:release --threads:on eth/p2p/discoveryv5/dcli\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## See all options")]),t._v("\n./eth/p2p/discoveryv5/dcli --help\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Ping another node")]),t._v("\n./eth/p2p/discoveryv5/dcli "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ping")]),t._v(" enr:"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("base64 encoding of ENR"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Run discovery node")]),t._v("\n./eth/p2p/discoveryv5/dcli --log-level:debug --bootnode:enr:"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("base64 encoding of ENR"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("h4",{attrs:{id:"metrics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#metrics"}},[t._v("#")]),t._v(" Metrics")]),t._v(" "),s("p",[t._v("To run dcli with metrics enabled provide the "),s("code",[t._v("metrics")]),t._v(" flag:")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Run dcli with metrics")]),t._v("\n./eth/p2p/discoveryv5/dcli --metrics --bootnode:enr:"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("base64 encoding of ENR"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("You can now see the metrics at http://localhost:8008/metrics. Or use e.g.\nPrometheus to grab the data.")]),t._v(" "),s("h2",{attrs:{id:"prerequisites"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prerequisites"}},[t._v("#")]),t._v(" Prerequisites")]),t._v(" "),s("ul",[s("li",[t._v("Nim & Nimble")]),t._v(" "),s("li",[t._v("RocksDB, SQLite, LMDB (required for the trie backend tests)")])]),t._v(" "),s("p",[t._v("E.g. on Ubuntu one can run:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("apt install -y librocksdb-dev liblmdb-dev sqlite3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h2",{attrs:{id:"building-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#building-testing"}},[t._v("#")]),t._v(" Building & Testing")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# Install required modules\nnimble install\n# Run full test suite\nnimble test\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("You can also run specific parts of the test suite, e.g.:")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# Test p2p functionality\nnimble test_p2p\n# Test rlp functionality\nnimble test_rlp\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h2",{attrs:{id:"fuzzing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fuzzing"}},[t._v("#")]),t._v(" Fuzzing")]),t._v(" "),s("p",[t._v("Next to the test suite, there are also several fuzzing test cases available.\nHow these can be run is explained in the "),s("a",{attrs:{href:"https://github.com/status-im/nim-eth/blob/master/tests/fuzzing/readme.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("fuzzing readme"),s("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);e.default=n.exports}}]);